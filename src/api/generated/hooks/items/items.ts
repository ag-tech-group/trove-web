/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * Trove API
 * Personal collection management API for tracking antiques, art, and valuables
 * OpenAPI spec version: 0.2.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  ItemCreate,
  ItemRead,
  ItemUpdate,
  ListItemsItemsGetParams
} from '../../types';

import { orvalClient } from '../../../orval-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List all items for the current user with optional filters.
 * @summary List Items
 */
export type listItemsItemsGetResponse200 = {
  data: ItemRead[]
  status: 200
}

export type listItemsItemsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type listItemsItemsGetResponseSuccess = (listItemsItemsGetResponse200) & {
  headers: Headers;
};
export type listItemsItemsGetResponseError = (listItemsItemsGetResponse422) & {
  headers: Headers;
};

export type listItemsItemsGetResponse = (listItemsItemsGetResponseSuccess | listItemsItemsGetResponseError)

export const getListItemsItemsGetUrl = (params?: ListItemsItemsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/items?${stringifiedParams}` : `/items`
}

export const listItemsItemsGet = async (params?: ListItemsItemsGetParams, options?: RequestInit): Promise<listItemsItemsGetResponse> => {
  
  return orvalClient<listItemsItemsGetResponse>(getListItemsItemsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListItemsItemsGetQueryKey = (params?: ListItemsItemsGetParams,) => {
    return [
    `/items`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListItemsItemsGetQueryOptions = <TData = Awaited<ReturnType<typeof listItemsItemsGet>>, TError = HTTPValidationError>(params?: ListItemsItemsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListItemsItemsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listItemsItemsGet>>> = ({ signal }) => listItemsItemsGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListItemsItemsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listItemsItemsGet>>>
export type ListItemsItemsGetQueryError = HTTPValidationError


export function useListItemsItemsGet<TData = Awaited<ReturnType<typeof listItemsItemsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListItemsItemsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listItemsItemsGet>>,
          TError,
          Awaited<ReturnType<typeof listItemsItemsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListItemsItemsGet<TData = Awaited<ReturnType<typeof listItemsItemsGet>>, TError = HTTPValidationError>(
 params?: ListItemsItemsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listItemsItemsGet>>,
          TError,
          Awaited<ReturnType<typeof listItemsItemsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListItemsItemsGet<TData = Awaited<ReturnType<typeof listItemsItemsGet>>, TError = HTTPValidationError>(
 params?: ListItemsItemsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Items
 */

export function useListItemsItemsGet<TData = Awaited<ReturnType<typeof listItemsItemsGet>>, TError = HTTPValidationError>(
 params?: ListItemsItemsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listItemsItemsGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListItemsItemsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Create a new item.
 * @summary Create Item
 */
export type createItemItemsPostResponse201 = {
  data: ItemRead
  status: 201
}

export type createItemItemsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createItemItemsPostResponseSuccess = (createItemItemsPostResponse201) & {
  headers: Headers;
};
export type createItemItemsPostResponseError = (createItemItemsPostResponse422) & {
  headers: Headers;
};

export type createItemItemsPostResponse = (createItemItemsPostResponseSuccess | createItemItemsPostResponseError)

export const getCreateItemItemsPostUrl = () => {


  

  return `/items`
}

export const createItemItemsPost = async (itemCreate: ItemCreate, options?: RequestInit): Promise<createItemItemsPostResponse> => {
  
  return orvalClient<createItemItemsPostResponse>(getCreateItemItemsPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      itemCreate,)
  }
);}




export const getCreateItemItemsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createItemItemsPost>>, TError,{data: ItemCreate}, TContext>, request?: SecondParameter<typeof orvalClient>}
): UseMutationOptions<Awaited<ReturnType<typeof createItemItemsPost>>, TError,{data: ItemCreate}, TContext> => {

const mutationKey = ['createItemItemsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createItemItemsPost>>, {data: ItemCreate}> = (props) => {
          const {data} = props ?? {};

          return  createItemItemsPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateItemItemsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createItemItemsPost>>>
    export type CreateItemItemsPostMutationBody = ItemCreate
    export type CreateItemItemsPostMutationError = HTTPValidationError

    /**
 * @summary Create Item
 */
export const useCreateItemItemsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createItemItemsPost>>, TError,{data: ItemCreate}, TContext>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createItemItemsPost>>,
        TError,
        {data: ItemCreate},
        TContext
      > => {
      return useMutation(getCreateItemItemsPostMutationOptions(options), queryClient);
    }
    /**
 * Get a single item by ID.
 * @summary Get Item
 */
export type getItemItemsItemIdGetResponse200 = {
  data: ItemRead
  status: 200
}

export type getItemItemsItemIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getItemItemsItemIdGetResponseSuccess = (getItemItemsItemIdGetResponse200) & {
  headers: Headers;
};
export type getItemItemsItemIdGetResponseError = (getItemItemsItemIdGetResponse422) & {
  headers: Headers;
};

export type getItemItemsItemIdGetResponse = (getItemItemsItemIdGetResponseSuccess | getItemItemsItemIdGetResponseError)

export const getGetItemItemsItemIdGetUrl = (itemId: string,) => {


  

  return `/items/${itemId}`
}

export const getItemItemsItemIdGet = async (itemId: string, options?: RequestInit): Promise<getItemItemsItemIdGetResponse> => {
  
  return orvalClient<getItemItemsItemIdGetResponse>(getGetItemItemsItemIdGetUrl(itemId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetItemItemsItemIdGetQueryKey = (itemId: string,) => {
    return [
    `/items/${itemId}`
    ] as const;
    }

    
export const getGetItemItemsItemIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError = HTTPValidationError>(itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetItemItemsItemIdGetQueryKey(itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemItemsItemIdGet>>> = ({ signal }) => getItemItemsItemIdGet(itemId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(itemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemItemsItemIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getItemItemsItemIdGet>>>
export type GetItemItemsItemIdGetQueryError = HTTPValidationError


export function useGetItemItemsItemIdGet<TData = Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError = HTTPValidationError>(
 itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemItemsItemIdGet>>,
          TError,
          Awaited<ReturnType<typeof getItemItemsItemIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemItemsItemIdGet<TData = Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError = HTTPValidationError>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getItemItemsItemIdGet>>,
          TError,
          Awaited<ReturnType<typeof getItemItemsItemIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemItemsItemIdGet<TData = Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError = HTTPValidationError>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Item
 */

export function useGetItemItemsItemIdGet<TData = Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError = HTTPValidationError>(
 itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemItemsItemIdGet>>, TError, TData>>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetItemItemsItemIdGetQueryOptions(itemId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update an item.
 * @summary Update Item
 */
export type updateItemItemsItemIdPatchResponse200 = {
  data: ItemRead
  status: 200
}

export type updateItemItemsItemIdPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateItemItemsItemIdPatchResponseSuccess = (updateItemItemsItemIdPatchResponse200) & {
  headers: Headers;
};
export type updateItemItemsItemIdPatchResponseError = (updateItemItemsItemIdPatchResponse422) & {
  headers: Headers;
};

export type updateItemItemsItemIdPatchResponse = (updateItemItemsItemIdPatchResponseSuccess | updateItemItemsItemIdPatchResponseError)

export const getUpdateItemItemsItemIdPatchUrl = (itemId: string,) => {


  

  return `/items/${itemId}`
}

export const updateItemItemsItemIdPatch = async (itemId: string,
    itemUpdate: ItemUpdate, options?: RequestInit): Promise<updateItemItemsItemIdPatchResponse> => {
  
  return orvalClient<updateItemItemsItemIdPatchResponse>(getUpdateItemItemsItemIdPatchUrl(itemId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      itemUpdate,)
  }
);}




export const getUpdateItemItemsItemIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>, TError,{itemId: string;data: ItemUpdate}, TContext>, request?: SecondParameter<typeof orvalClient>}
): UseMutationOptions<Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>, TError,{itemId: string;data: ItemUpdate}, TContext> => {

const mutationKey = ['updateItemItemsItemIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>, {itemId: string;data: ItemUpdate}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updateItemItemsItemIdPatch(itemId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateItemItemsItemIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>>
    export type UpdateItemItemsItemIdPatchMutationBody = ItemUpdate
    export type UpdateItemItemsItemIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Item
 */
export const useUpdateItemItemsItemIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>, TError,{itemId: string;data: ItemUpdate}, TContext>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateItemItemsItemIdPatch>>,
        TError,
        {itemId: string;data: ItemUpdate},
        TContext
      > => {
      return useMutation(getUpdateItemItemsItemIdPatchMutationOptions(options), queryClient);
    }
    /**
 * Delete an item.
 * @summary Delete Item
 */
export type deleteItemItemsItemIdDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteItemItemsItemIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type deleteItemItemsItemIdDeleteResponseSuccess = (deleteItemItemsItemIdDeleteResponse204) & {
  headers: Headers;
};
export type deleteItemItemsItemIdDeleteResponseError = (deleteItemItemsItemIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteItemItemsItemIdDeleteResponse = (deleteItemItemsItemIdDeleteResponseSuccess | deleteItemItemsItemIdDeleteResponseError)

export const getDeleteItemItemsItemIdDeleteUrl = (itemId: string,) => {


  

  return `/items/${itemId}`
}

export const deleteItemItemsItemIdDelete = async (itemId: string, options?: RequestInit): Promise<deleteItemItemsItemIdDeleteResponse> => {
  
  return orvalClient<deleteItemItemsItemIdDeleteResponse>(getDeleteItemItemsItemIdDeleteUrl(itemId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteItemItemsItemIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalClient>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['deleteItemItemsItemIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  deleteItemItemsItemIdDelete(itemId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteItemItemsItemIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>>
    
    export type DeleteItemItemsItemIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Item
 */
export const useDeleteItemItemsItemIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>, TError,{itemId: string}, TContext>, request?: SecondParameter<typeof orvalClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteItemItemsItemIdDelete>>,
        TError,
        {itemId: string},
        TContext
      > => {
      return useMutation(getDeleteItemItemsItemIdDeleteMutationOptions(options), queryClient);
    }
    